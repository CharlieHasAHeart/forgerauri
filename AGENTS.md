# AGENTS.md â€” ForgeTauri Project Rules

This repository contains a code-generation agent that turns a JSON "app spec" into a runnable
desktop application built with:
- Tauri v2
- Svelte
- TypeScript
- Rust commands
- SQLite (rusqlite)

The agent itself is implemented in Node.js + TypeScript.

These rules are **authoritative**. Follow them when planning, generating, or modifying code.

---

## 1) High-level goals

1. **Deterministic generation**
   - Same input spec => same output project structure and code (modulo timestamps).
2. **Idempotency**
   - Running the generator multiple times should not corrupt the generated project.
3. **Safety**
   - Never perform destructive operations outside the project directory.
   - Prefer generating a patch/diff and then applying it.
4. **Strong contracts**
   - Normalize the spec into a stable IR before any generation.
   - Enforce naming uniqueness and schema sanity early.
5. **Separation of concerns in the generated app**
   - Svelte UI
   - TS invoke layer
   - Rust commands
   - Rust services (business logic)
   - Rust db repos (rusqlite + SQL)
   - SQL migrations

---

## 2) Repository structure (agent code)

The agent code MUST follow this structure:

- `src/spec/`
  - `schema.ts` (zod schema + normalization rules)
  - `loadSpec.ts` (read file + parse + validate + return IR)
- `src/generator/`
  - `scaffold/` (project skeleton generator)
  - `templates/` (text templates only; no logic)
  - `render.ts` (template render helper)
  - `plan.ts` (build a generation plan: list of files + actions)
  - `apply.ts` (apply plan with safe write rules)
- `src/cli.ts` (CLI entry)
- `src/index.ts` (exports public API)
- `tests/` (vitest)

If a file does not exist yet, create it in the appropriate location.

---

## 3) The Spec IR (Internal Representation)

All generation MUST operate on a validated, normalized Spec IR.

Rules:
- Unknown fields in the raw JSON are allowed, but the full original JSON must be preserved in `ir.raw`.
- Defaults must be applied during normalization (not later).
- Names must be unique:
  - `screens[].name` unique
  - `rust_commands[].name` unique
  - `data_model.tables[].name` unique
  - `columns[].name` unique per table
- Normalize:
  - `columns[].type`: `trim()` + `toLowerCase()`
  - `screens[].primary_actions`: default `[]`
  - `rust_commands[].async`: default `true`
  - `rust_commands[].input` and `.output`: default `{}`

Error reporting:
- Validation failures must be actionable and readable:
  - include path + message per issue
  - exit with non-zero status in CLI

---

## 4) Generation plan and apply rules

The generator must produce a **Plan** before writing to disk.

### 4.1 Plan requirements
- Plan is an ordered list of actions:
  - `CREATE`, `OVERWRITE`, `SKIP`, `PATCH`
- Each action includes:
  - target path
  - reason
  - content or patch
  - whether it is safe to apply without user confirmation

### 4.2 Apply rules (file safety)
- Never write outside the workspace root.
- Default mode: generate patch/diff first; apply only when requested by CLI flag.
- Define two zones in the generated app:
  1) **Generated zone** (safe to overwrite):
     - `generated/` OR `src-tauri/generated/` OR any directory explicitly marked generated by this project
  2) **User zone** (do NOT overwrite automatically):
     - anything else, especially:
       - `src/lib/custom/`
       - `src-tauri/src/custom/`
- If a file exists in user zone:
  - do not overwrite
  - produce a `PATCH` suggestion or emit a warning with a recommended manual merge

### 4.3 Determinism
- Do not include timestamps in generated content unless explicitly required.
- Sort lists (screens, commands, tables) in a stable way when generating.

---

## 5) Generated desktop app architecture rules (Tauri v2 + Svelte + Rust)

### 5.1 Rust layering (MUST)
- `commands/`:
  - only argument parsing/validation + call service
  - no SQL here
- `services/`:
  - business logic and transaction boundaries
- `db/`:
  - rusqlite + SQL only
  - no UI-related logic
- `models/`:
  - Rust structs shared between layers

### 5.2 Command response contract (MUST)
All Rust commands must return a unified response shape:

- Success: `{ ok: true, data: T }`
- Failure: `{ ok: false, error: { code: string, message: string, detail?: string } }`

Front-end must treat all invocations through one wrapper that enforces this shape.

### 5.3 SQLite migrations (MUST)
- Migrations live in `src-tauri/migrations/`
- On app startup, migrations are applied in order.
- The DB schema version is tracked (e.g., `schema_migrations` table).
- Migrations must be append-only; never edit old migrations once released.

### 5.4 Long-running tasks
- Use Tauri events for progress reporting when a command might take noticeable time.

---

## 6) Tooling and scripts (agent repo)

This repository (agent code) must include:
- TypeScript build: `tsc`
- Tests: `vitest`
- Lint/format are optional, but code must be clean and consistent.

`package.json` scripts should include at least:
- `dev`: run CLI via tsx/ts-node or build+run
- `build`: `tsc -p tsconfig.json`
- `test`: `vitest run`

Prefer `pnpm` if present; otherwise `npm` is acceptable.

---

## 7) Code style

TypeScript:
- Use ESM or CJS consistently (choose one and keep it consistent).
- Prefer explicit types at module boundaries.
- Never use `any` unless justified; prefer `unknown` and validate/narrow.
- Use small pure functions for normalization.
- Errors: create typed error classes for predictable failures.

Rust (generated):
- Prefer `thiserror` for errors and `serde` for serialization.
- Keep modules small and purposeful.
- Avoid `unwrap()` in non-test code.

SQL:
- Use clear naming:
  - snake_case table and column names.
- Add indexes when a table is listed or filtered frequently.

---

## 8) CLI requirements

CLI should support:
- `--spec <path>` (or positional arg)
- `--out <dir>` output directory
- `--plan` to print plan without applying
- `--apply` to write changes
- `--dry-run` equivalent is acceptable

CLI output:
- Print validation summary
- Print plan summary (#create/#overwrite/#patch/#skip)
- On apply: print what was written

Exit codes:
- `0` success
- `1` validation error
- `2` generation/apply error

---

## 9) Tests (minimum expectations)

At minimum:
- Valid spec parses and normalizes into IR with defaults.
- Duplicate command name fails.
- Duplicate table column name fails.

Tests must be deterministic and not rely on network access.

---

## 10) Decision policy

When uncertain:
1) Prefer safety (do not overwrite user zone files)
2) Prefer determinism
3) Prefer clearer error messages over clever inference

If the spec is missing essential information:
- fail fast with a precise validation error
- do not guess silently

---

## 11) Known input examples

During development, ensure the CLI can read and validate specs at paths similar to:
- `/mnt/data/browniebroke__deezer-python.json`
- `/mnt/data/lablup__backend.ai.json`
- `/mnt/data/NaturalIntelligence__fast-xml-parser.json`
- `/mnt/data/s3rgeym__hh-applicant-tool.json`

(These paths may exist in the dev environment; the code should accept any file path.)

---

## 12) Security note

Never:
- execute arbitrary shell commands from spec content
- write outside the chosen output directory
- delete user files automatically

Always:
- validate inputs
- keep changes auditable (plan/diff)